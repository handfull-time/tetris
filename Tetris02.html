<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta author="utimezgd@gmail.com" />
    <meta url="https://github.com/handfull-time/tetris" />
    <meta url="https://handfull-time.github.io/tetris/" />

    <title>Tetris</title>
    <style>
      canvas {
        border: 1px solid rgb(0, 0, 0);
      }
      table {
        border-collapse: collapse;
      }

      td {
        width: 120px;
        height: 30px;
        border: none;
      }
    </style>

    <script type="application/javascript">
      /**
       * Item image size
       */
      const BLOCK_SIZE = 16;
      /**
       * Tetris default definition value.
       * Horizontal is the X-axis, vertical is the Y-axis (X, Y)
       */
      const TetrisDefine = {
        // Tetris board size
        MATRIX_X: parseInt((window.innerWidth - 20) / BLOCK_SIZE),
        MATRIX_Y: parseInt(window.innerHeight / BLOCK_SIZE) - 7,
        // Item block size
        PIECE_SIZE: 4,
        // Even numbers are better than odd numbers for item image size.
        PIECE_IMG_SIZE: BLOCK_SIZE,
      };

      TetrisDefine.MATRIX_BETWEEN = TetrisDefine.PIECE_SIZE - 1;

      TetrisDefine.MATRIX_GAP = TetrisDefine.MATRIX_BETWEEN * 2;

      TetrisDefine.MATRIX_BR_X = TetrisDefine.MATRIX_X + TetrisDefine.MATRIX_GAP;
      TetrisDefine.MATRIX_BR_Y = TetrisDefine.MATRIX_Y + TetrisDefine.MATRIX_GAP;

      TetrisDefine.MATRIX_WORK_X = TetrisDefine.MATRIX_BR_X - TetrisDefine.MATRIX_BETWEEN;
      TetrisDefine.MATRIX_WORK_Y = TetrisDefine.MATRIX_BR_Y - TetrisDefine.MATRIX_BETWEEN;

      Object.freeze(TetrisDefine);
      // ------------------------------------------------------------------------------------------------------------------------------------------------------- \\

      /**
       *  Tetris state
       */
      const TetrisStatus = {
        // Game start waiting state
        Begin: 0,
        // Game in progress
        Play: 1,
        // Game over
        Finish: 2,
      };
      Object.freeze(TetrisStatus);

      // ------------------------------------------------------------------------------------------------------------------------------------------------------- \\

      /**
       * Color of Tetris piece item
       */
      const PieceColor = {
        PIECE_NO: -1, // No painting
        PIECE_BL: 0, // BLACK
        PIECE_RD: 1, // RED
        PIECE_YW: 2, // YELLOW
        PIECE_LG: 3, // LIGHT GREEN
        PIECE_GR: 4, // GREEN
        PIECE_BU: 5, // BLUE
        PIECE_OR: 6, // ORANGE
        PIECE_PP: 7, // PURPLE
        PIECE_NV: 8, // NAVY BLUE
      };
      Object.freeze(PieceColor);

      // ------------------------------------------------------------------------------------------------------------------------------------------------------- \\

      /**
       * Tetris piece item
       */
      class PieceItem {
        constructor(pieceinf) {
          const N = TetrisDefine.PIECE_SIZE;
          this.Piece = this.getDummy(N, 0);

          for (let i = 0; i < N; i++) {
            for (let j = 0; j < N; j++) {
              this.Piece[i][j] = pieceinf[i][j];
            }
          }
        }

        /**
         * Create an empty value array
         * @param {size} size
         * @param {defaultValue} default value.
         */
        getDummy(size, defaultValue) {
          return new Array(size).fill(null).map(() => new Array(size).fill(defaultValue));
        }

        /**
         * Rotate Tetris piece item clockwise
         */
        getRotateClockwise() {
          const N = TetrisDefine.PIECE_SIZE;
          const data = this.getDummy(N, 0);

          for (let i = 0; i < N; i++) {
            for (let j = 0; j < N; j++) {
              data[j][N - 1 - i] = this.Piece[i][j];
            }
          }

          return new PieceItem(data);
        }

        /**
         * Rotate Tetris piece item counter-clockwise
         */
        getRotateCounterClockwise() {
          const N = TetrisDefine.PIECE_SIZE;
          const data = this.getDummy(N, 0);

          for (let i = 0; i < N; i++) {
            for (let j = 0; j < N; j++) {
              data[N - 1 - j][i] = this.Piece[i][j];
            }
          }
          return new PieceItem(data);
        }

        /**
         * clone
         */
        clone() {
          const N = TetrisDefine.PIECE_SIZE;
          const data = this.getDummy(N, 0);

          for (let i = 0; i < N; i++) {
            for (let j = 0; j < N; j++) {
              data[i][j] = this.Piece[i][j];
            }
          }

          return new PieceItem(data);
        }

        /**
         * comment
         */
        toString() {
          const N = TetrisDefine.PIECE_SIZE;
          let str = "";
          for (let i = 0; i < N; i++) {
            for (let j = 0; j < N; j++) {
              str += " " + String(this.Piece[i][j] * 1).padStart(2, " ");
            }
            str += "\n";
          }
          return str;
        }
      }

      // ------------------------------------------------------------------------------------------------------------------------------------------------------- \\

      /**
       * Tetris item list
       */
      class PieceList {
        constructor() {
          this.PieceItems = [];

          // □ Square shape
          this.PieceItems.push(
            new PieceItem([
              [PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_RD, PieceColor.PIECE_RD, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_RD, PieceColor.PIECE_RD, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
            ])
          );

          // ┗ shape
          this.PieceItems.push(
            new PieceItem([
              [PieceColor.PIECE_NO, PieceColor.PIECE_YW, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_YW, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_YW, PieceColor.PIECE_YW, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
            ])
          );

          // ┒┕ Combined shape
          this.PieceItems.push(
            new PieceItem([
              [PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
              [PieceColor.PIECE_LG, PieceColor.PIECE_LG, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_LG, PieceColor.PIECE_LG, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
            ])
          );

          // ┷ shape
          this.PieceItems.push(
            new PieceItem([
              [PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_GR, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
              [PieceColor.PIECE_GR, PieceColor.PIECE_GR, PieceColor.PIECE_GR, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
            ])
          );

          // ┃ shape
          this.PieceItems.push(
            new PieceItem([
              [PieceColor.PIECE_NO, PieceColor.PIECE_OR, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_OR, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_OR, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_OR, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
            ])
          );

          // ┙ shape
          this.PieceItems.push(
            new PieceItem([
              [PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NV, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NV, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_NV, PieceColor.PIECE_NV, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
            ])
          );

          // ┛┌ Combined shape
          this.PieceItems.push(
            new PieceItem([
              [PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_PP, PieceColor.PIECE_PP, PieceColor.PIECE_NO],
              [PieceColor.PIECE_PP, PieceColor.PIECE_PP, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
              [PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO, PieceColor.PIECE_NO],
            ])
          );
        }

        /**
         * Index position data
         * @param {index} index
         */
        getItem(index) {
          const Result = this.PieceItems[index];
          return Result.clone();
        }

        /**
         * Random data
         */
        getRandomItem() {
          return this.getItem(Math.floor(Math.random() * this.PieceItems.length));
        }
      }

      // ------------------------------------------------------------------------------------------------------------------------------------------------------- \\

      /**
       * Tetris board
       */
      class BoardGround {
        constructor() {
          this.Board = new Array(TetrisDefine.MATRIX_BR_Y).fill(null).map(() => new Array(TetrisDefine.MATRIX_BR_X).fill(PieceColor.PIECE_NO));
          this.init();
        }

        /**
         * Initialization
         */
        init() {
          for (let y = 0; y < TetrisDefine.MATRIX_WORK_Y; y++) {
            for (let x = TetrisDefine.MATRIX_BETWEEN; x < TetrisDefine.MATRIX_WORK_X; x++) {
              this.Board[y][x] = PieceColor.PIECE_BL;
            }
          }
        }

        /**
         * comment
         */
        toString() {
          let str = "";
          for (let y = 0; y < TetrisDefine.MATRIX_BR_Y; y++) {
            for (let x = 0; x < TetrisDefine.MATRIX_BR_X; x++) {
              str += "[" + String(x).padStart(2, " ") + "," + String(y).padStart(2, " ") + "," + String(this.Board[y][x]).padStart(2, " ") + "] ";
            }
            str += "\n";
          }

          return str;
        }
      }

      // ------------------------------------------------------------------------------------------------------------------------------------------------------- \\

      /**
       * Tetris main class
       */
      class TetrisManager {
        constructor(mainCanvasId, waitCanvasId) {
          // Functions called internally from events or callbacks need to be bound.

          // Initialization
          this.init = this.init.bind(this);
          // Function to be called at a set time.
          this.moveInterval = this.moveInterval.bind(this);
          // Key event function
          this.handleKeyDown = this.handleKeyDown.bind(this);
          // Move left
          this.movePieceLeft = this.movePieceLeft.bind(this);
          // Move right
          this.movePieceRight = this.movePieceRight.bind(this);
          // down
          this.downPiece = this.downPiece.bind(this);
          // bottom
          this.bottomPiece = this.bottomPiece.bind(this);
          // rotate
          this.rotatePiece = this.rotatePiece.bind(this);

          this.board = new BoardGround();
          this.piece = new PieceList();
          this.play = new Object();
          this.intervalId = null;

          // Canvas settings
          this._setCanvas(mainCanvasId, waitCanvasId);

          this.init();
        }

        /**
         * Initialization
         */
        init() {
          this.board.init();
          this.play.x = 0;
          this.play.y = 0;
          this.playPiece = null;
          this.waitPiece = null;
          this.intervalTime = 1500;
          this.gamePoint = 0;
          this.gemeLevel = 0;
          this.status = TetrisStatus.Begin;
          if (this.intervalId != null) clearInterval(this.intervalId);
          this.intervalId = null;
        }

        /**
         * Canvas settings
         * @param {mainCanvasId} Main canvas ID
         * @param {waitCanvasId} Waiting block canvas ID
         */
        _setCanvas(mainCanvasId, waitCanvasId) {
          this.canvas = document.getElementById(mainCanvasId);
          if (!this.canvas) {
            throw new Error(mainCanvasId + " Canvas id not found.");
          }
          if (this.canvas.getContext) {
            this.canvas.width = TetrisDefine.PIECE_IMG_SIZE * TetrisDefine.MATRIX_X;
            this.canvas.height = TetrisDefine.PIECE_IMG_SIZE * TetrisDefine.MATRIX_Y;

            this.ctx = this.canvas.getContext("2d");
            this.canvas.ownerObject = this;
          }

          this.canvas.addEventListener("click", function (event) {
            const manager = event.currentTarget.ownerObject;

            if (manager.status == TetrisStatus.Begin) {
              manager.start();
            }
          });

          this.waitCanvas = document.getElementById(waitCanvasId);
          if (!this.waitCanvas) {
            throw new Error(waitCanvasId + " Canvas id not found.");
          }
          if (this.waitCanvas.getContext) {
            this.waitCanvas.width = TetrisDefine.PIECE_IMG_SIZE * TetrisDefine.PIECE_SIZE;
            this.waitCanvas.height = this.waitCanvas.width;
            this.waitCtx = this.waitCanvas.getContext("2d");
          }
        }

        /**
         * comment
         */
        toString() {
          let result = "\n";
          result += "Board\n" + this.board.toString();
          if (this.playPiece != null) result += "PlayPiece\n" + this.playPiece.toString();
          result += "\nPlay position : x=" + this.play.x + ", y=" + this.play.y;
          result += "\nGame Point : " + this.gamePoint;
          result += "\nInterval Time :" + this.intervalTime;
          return result;
        }

        /**
         * game start.
         */
        start() {
          // Change status to start.
          this.status = TetrisStatus.Play;
          // New item to proceed with. Initially, it doesn't matter as long as it's not null.
          this.playPiece = {};
          // Item to wait for
          this.waitPiece = this.piece.getRandomItem();

          for (let i = 0; i < Math.floor(Math.random() * TetrisDefine.PIECE_SIZE); i++) {
            this.waitPiece = this.waitPiece.getRotateClockwise();
          }

          this.nextPiece();

          this.procInterval();
        }

        /**
         * Proceed every set time.
         */
        procInterval() {
          this.intervalTime -= 90;
          if (this.intervalTime <= 0) {
            return;
          }

          if (this.intervalId != null) {
            clearInterval(this.intervalId);
          }

          this.intervalId = setInterval(this.moveInterval, this.intervalTime);
        }

        /**
         * Next block appears
         */
        nextPiece() {
          if (this.status != TetrisStatus.Play) return;

          // Move the new position of the item
          this.play.x = TetrisDefine.MATRIX_BETWEEN + Math.floor(Math.random() * (TetrisDefine.MATRIX_X - TetrisDefine.MATRIX_BETWEEN));
          this.play.y = 0;
          //console.info("play position", "x=" + this.play.x, "y=" + this.play.y);

          // Change waiting item to play item
          this.playPiece = this.waitPiece;
          this.waitPiece = this.piece.getRandomItem();

          for (let i = 0; i < Math.floor(Math.random() * TetrisDefine.PIECE_SIZE); i++) {
            this.waitPiece = this.waitPiece.getRotateClockwise();
          }
        }

        /**
         * Determine if left, right, and bottom movements are possible.
         * @Param {addX} Horizontal movement info. Negative values for left, positive values for right.
         * @Param {addY} Vertical movement info. Negative values for up, positive values for down.
         * @Param {piece} Piece of item to move
         * @return true: movement is possible. false: movement is impossible.
         */
        checkWidthBlockPiece(addX, addY, piece) {
          const prex = this.play.x + addX;
          const prey = this.play.y + addY;

          // console.info("X", prex, "Y", prey, "piece", piece.toString());

          // let str = "";
          // for (let y = prey, i = 0; i < TetrisDefine.PIECE_SIZE; i++, y++) {
          //   for (let x = prex, j = 0; j < TetrisDefine.PIECE_SIZE; j++, x++) {
          //     str +=
          //       "[(" +
          //       String(x).padStart(2, " ") +
          //       ", " +
          //       String(y).padStart(2, " ") +
          //       ", " +
          //       String(this.board.Board[y][x]).padStart(2, " ") +
          //       ") (" +
          //       String(j).padStart(2, " ") +
          //       ", " +
          //       String(i).padStart(2, " ") +
          //       ", " +
          //       String(piece.Piece[i][j]).padStart(2, " ") +
          //       ")] ";
          //   }
          //   str += "\n";
          // }
          // console.info(str);

          let result = true;
          loopCheck: for (let y = prey, i = 0; i < TetrisDefine.PIECE_SIZE; i++, y++) {
            for (let x = prex, j = 0; j < TetrisDefine.PIECE_SIZE; j++, x++) {
              if (piece.Piece[i][j] != PieceColor.PIECE_NO) {
                if (this.board.Board[y][x] != PieceColor.PIECE_BL) {
                  // console.info(
                  //   "touch",
                  //   "[(" +
                  //     String(x).padStart(2, " ") +
                  //     ", " +
                  //     String(y).padStart(2, " ") +
                  //     ", " +
                  //     String(this.board.Board[y][x]).padStart(2, " ") +
                  //     ") (" +
                  //     String(j).padStart(2, " ") +
                  //     ", " +
                  //     String(i).padStart(2, " ") +
                  //     ", " +
                  //     String(piece.Piece[i][j]).padStart(2, " ") +
                  //     ")] "
                  // );
                  result = false;
                  break loopCheck;
                }
              }
            }
          }

          if (result) {
            this.play.x += addX;
            this.play.y += addY;
          }
          return result;
        }

        /**
         * Check if it touches below.
         * Combine Board and playPiece.
         * @return true: it touched. false: it didn't touch.
         */
        boardMergePiece() {
          let isMerge = false;
          loopMerge: for (let y = this.play.y + TetrisDefine.PIECE_SIZE, i = TetrisDefine.PIECE_SIZE - 1; i > 0; i--, y--) {
            for (let x = this.play.x, j = 0; j < TetrisDefine.PIECE_SIZE; j++, x++) {
              if (this.playPiece.Piece[i][j] != PieceColor.PIECE_NO) {
                if (this.board.Board[y][x] != PieceColor.PIECE_BL) {
                  // console.info(
                  //   "touch",
                  //   "[(" +
                  //     String(x).padStart(2, " ") +
                  //     ", " +
                  //     String(y).padStart(2, " ") +
                  //     ", " +
                  //     String(this.board.Board[y][x]).padStart(2, " ") +
                  //     ") (" +
                  //     String(j).padStart(2, " ") +
                  //     ", " +
                  //     String(i).padStart(2, " ") +
                  //     ", " +
                  //     String(this.playPiece.Piece[i][j]).padStart(2, " ") +
                  //     ")] "
                  // );
                  isMerge = true;
                  break loopMerge;
                }
              }
            }
          }

          if (isMerge) {
            // Attach to the main since it finally reached the bottom.
            for (let y = this.play.y, i = 0; i < TetrisDefine.PIECE_SIZE; i++, y++) {
              for (let x = this.play.x, j = 0; j < TetrisDefine.PIECE_SIZE; j++, x++) {
                if (this.playPiece.Piece[i][j] != PieceColor.PIECE_NO) {
                  this.board.Board[y][x] = this.playPiece.Piece[i][j];
                }
              }
            }
          }

          return isMerge;
        }

        /**
         * Determine success. Change points.
         */
        checkSuccessLine() {
          const wCnt = TetrisDefine.MATRIX_X + TetrisDefine.MATRIX_BETWEEN;
          let successCount = 0;
          for (let y = TetrisDefine.MATRIX_WORK_Y - 1; y >= 0; y--) {
            let count = 0;
            for (let x = TetrisDefine.MATRIX_BETWEEN; x < wCnt; x++) {
              count += this.board.Board[y][x] == PieceColor.PIECE_BL ? 0 : 1;
            }

            if (count == TetrisDefine.MATRIX_X) {
              successCount++;

              for (let in_y = y; in_y > 0; in_y--) {
                for (let x = TetrisDefine.MATRIX_BETWEEN; x < wCnt; x++) {
                  this.board.Board[in_y][x] = this.board.Board[in_y - 1][x];
                }
              }
              y++;
            }
          }

          if (successCount > 0) {
            // Increase score points.
            this.gamePoint += 10 * (successCount + (successCount - 1));

            if (this.gamePoint / 200 > this.gemeLevel) {
              // Proceed with the time faster.
              this.gameLevel++;
              this.procInterval();
            }
          }
        }

        /**
         * Move to the left.
         */
        movePieceLeft() {
          if (this.status != TetrisStatus.Play) return;

          this.checkWidthBlockPiece(-1, 0, this.playPiece);
        }

        /**
         * Move to the right.
         */
        movePieceRight() {
          if (this.status != TetrisStatus.Play) return;

          this.checkWidthBlockPiece(1, 0, this.playPiece);
        }

        /**
         * Move downward.
         */
        downPiece() {
          if (this.status != TetrisStatus.Play) return;

          if (!this.checkWidthBlockPiece(0, 1, this.playPiece)) {
            if (this.boardMergePiece()) {
              this.checkSuccessLine();
            }
            this.nextPiece();
            this.checkEndGame();
          }
        }

        /**
         * Move to the floor.
         */
        bottomPiece() {
          if (this.status != TetrisStatus.Play) return;

          while (this.checkWidthBlockPiece(0, 1, this.playPiece)) {}

          if (this.boardMergePiece()) {
            this.checkSuccessLine();
          }
          this.nextPiece();
          this.checkEndGame();
        }

        /**
         * Rotate the item shape.
         */
        rotatePiece() {
          if (this.status != TetrisStatus.Play) return;

          const rotate = this.playPiece.getRotateClockwise();
          if (this.checkWidthBlockPiece(0, 0, rotate)) {
            this.playPiece = rotate;
          }
        }

        /**
         * Moves at a set time.
         */
        moveInterval() {
          if (this.status != TetrisStatus.Play) return;

          this.downPiece();
        }

        /**
         * Determine if the game is over.
         */
        checkEndGame() {
          let count = 0;
          const wCnt = TetrisDefine.MATRIX_X + TetrisDefine.MATRIX_BETWEEN;
          for (let x = TetrisDefine.MATRIX_BETWEEN; x < wCnt; x++) {
            count += this.board.Board[TetrisDefine.MATRIX_BETWEEN][x] == PieceColor.PIECE_BL ? 0 : 1;
          }

          if (count > 0) {
            console.info("The end~");
            if (this.intervalId != null) clearInterval(this.intervalId);
            this.status = TetrisStatus.Finish;
            clearCanvas(this.waitCtx);
            this.playPiece = null;
          }
        }

        /**
         * Keyboard down event.
         * @param {event} key down event.
         */
        handleKeyDown(event) {
          switch (event.keyCode) {
            case 37: {
              // left
              this.movePieceLeft();
              break;
            }
            case 39: {
              // right
              this.movePieceRight();
              break;
            }
            case 40: {
              // down
              this.downPiece();
              break;
            }
            case 32: {
              // spacebar
              this.bottomPiece();
              break;
            }
            case 38: {
              // up
              this.rotatePiece();
              break;
            }
            case 27: {
              // esc
              this.init();
              break;
            }
          }
        }
      } // Tetris end~

      // ------------------------------------------------------------------------------------------------------------------------------------------------------- \\

      /**
       * Arrow size to be displayed for touch events.
       */
      const ArrowSize = {
        Begin: 45,
        End: 70,
        Gap: 30,
      };
      Object.freeze(ArrowSize);

      /**
       * Arrow position to be displayed for touch events.
       */
      const ArrowDirection = {
        Up: 1,
        Down: 2,
        Left: 3,
        Right: 4,
      };
      Object.freeze(ArrowDirection);

      /**
       * Arrow color to be displayed for touch events.
       */
      const ArrowColor = {
        Normal: "rgb(200,0,0)",
        Select: "rgba(0, 0, 200, 0.5)",
      };
      Object.freeze(ArrowColor);

      /**
       * Arrow information.
       */
      class Arrow {
        constructor(x, y, direction) {
          this.x = x;
          this.y = y;
          this.direction = direction;
          this.color = ArrowColor.Normal;
        }
      }

      /**
       * Arrow list.
       */
      class Arrows {
        constructor() {
          // arrow list
          this.list = [];
          // Last touch information event. ArrowDirection
          this.lastDirection = null;
        }

        /**
         * Touch start.
         * @Param {x} Touch position x
         * @Param {y} Touch position y
         */
        touchStart(x, y) {
          this.list = [new Arrow(x, y, ArrowDirection.Up), new Arrow(x, y, ArrowDirection.Down), new Arrow(x, y, ArrowDirection.Left), new Arrow(x, y, ArrowDirection.Right)];
        }

        /**
         * Touch end.
         */
        touchEnd() {
          this.list = [];
          this.lastDirection = null;
        }

        /**
         * Touch move.
         * @Param {x} Touch move position  x
         * @Param {y} Touch move position  y
         */
        touchMove(x, y) {
          this.list.forEach((arrow) => {
            if (this._isInArrowBounds(x, y, arrow)) {
              this.lastDirection = arrow.direction;
              arrow.color = ArrowColor.Select;
            } else {
              arrow.color = ArrowColor.Normal;
            }
          });

          return this.lastDirection;
        }

        /**
         * Whether it entered the arrow or not
         * @param {touchX} Touch x-coordinate
         * @param {touchY} Touch y-coordinate
         * @param {arrow} Arrow
         * @return true: inside the arrow. false: outside the arrow.
         */
        _isInArrowBounds(touchX, touchY, arrow) {
          const x = arrow.x;
          const y = arrow.y;

          switch (arrow.direction) {
            case ArrowDirection.Up:
              return touchX >= x - ArrowSize.Begin && touchX <= x + ArrowSize.Begin && touchY >= y - ArrowSize.End && touchY <= y - ArrowSize.Gap;
            case ArrowDirection.Down:
              return touchX >= x - ArrowSize.Begin && touchX <= x + ArrowSize.Begin && touchY <= y + ArrowSize.End && touchY >= y + ArrowSize.Gap;
            case ArrowDirection.Left:
              return touchY >= y - ArrowSize.Begin && touchY <= y + ArrowSize.Begin && touchX >= x - ArrowSize.End && touchX <= x - ArrowSize.Gap;
            case ArrowDirection.Right:
              return touchY >= y - ArrowSize.Begin && touchY <= y + ArrowSize.Begin && touchX <= x + ArrowSize.End && touchX >= x + ArrowSize.Gap;
          }
          return false;
        }
      }
      // ------------------------------------------------------------------------------------------------------------------------------------------------------- \\

      /**
       * First-time page load.
       */
      function loadBody() {
        // Create a Tetris instance
        const tetris = new TetrisManager("canvasBoard", "canvasNext");
        // Touch arrows
        tetris.arrows = new Arrows();
        // Touch Double tap time
        tetris.tapTime = 0;

        // Event registration
        window.addEventListener("keydown", tetris.handleKeyDown);
        regButtonClickEvent("btnLeft", tetris.movePieceLeft);
        regButtonClickEvent("btnRight", tetris.movePieceRight);
        regButtonClickEvent("btnDown", tetris.downPiece);
        regButtonClickEvent("btnRotate", tetris.rotatePiece);
        regButtonClickEvent("btnBottom", tetris.bottomPiece);
        regButtonClickEvent("btnInit", tetris.init);

        // Register touch events in canvas (for mobile)
        const canvas = tetris.canvas;
        canvas.addEventListener("touchstart", handlerTouchStart, false);
        canvas.addEventListener("touchmove", handlerTouchMove, false);
        canvas.addEventListener("touchend", handlerTouchEnd, false);

        console.info(tetris.toString());

        draw(tetris);
      }

      /**
       * Registering Button Events
       * @param {id} element id
       * @param {event} function
       */
      function regButtonClickEvent(id, event) {
        const element = document.getElementById(id);
        element.addEventListener(
          "click",
          () => {
            event();
          },
          false
        );
      }

      /**
       * Touch Start Event
       * @param {e} event
       */
      function handlerTouchStart(e) {
        const canvas = e.target;
        const tetris = canvas.ownerObject;

        // Double-tap check
        const currentTime = new Date().getTime();
        if (currentTime - tetris.tapTime < 300) {
          // Two taps within 300 ms are considered a double tap
          tetris.tapTime = 0; // Reset tap time
          tetris.bottomPiece();
          return;
        } else {
          tetris.tapTime = currentTime;
        }

        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;

        tetris.arrows.touchStart(x, y);
      }

      /**
       * Touch movement events
       * @param {e} event
       */
      function handlerTouchMove(e) {
        const canvas = e.target;
        const tetris = canvas.ownerObject;
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        const x = touch.clientX - rect.left;
        const y = touch.clientY - rect.top;

        tetris.arrows.touchMove(x, y);
      }

      /**
       * Touch end events
       * @param {e} event
       */
      function handlerTouchEnd(e) {
        const canvas = e.target;
        const tetris = canvas.ownerObject;
        const arrows = tetris.arrows;

        switch (arrows.lastDirection) {
          case ArrowDirection.Up:
            tetris.rotatePiece();
            break;
          case ArrowDirection.Down:
            tetris.downPiece();
            break;
          case ArrowDirection.Left:
            tetris.movePieceLeft();
            break;
          case ArrowDirection.Right:
            tetris.movePieceRight();
            break;
        }

        arrows.touchEnd();
      }

      /**
       * Drawing touch arrows
       * @param {ctx} canvas context
       * @param {arrow} Arrow
       */
      function drawArrow(ctx, arrow) {
        const x = arrow.x;
        const y = arrow.y;

        ctx.fillStyle = arrow.color;

        ctx.beginPath();
        switch (arrow.direction) {
          case ArrowDirection.Up:
            ctx.moveTo(x, y - ArrowSize.Gap);
            ctx.lineTo(x + ArrowSize.Begin, y - ArrowSize.End);
            ctx.lineTo(x - ArrowSize.Begin, y - ArrowSize.End);
            break;
          case ArrowDirection.Down:
            ctx.moveTo(x, y + ArrowSize.Gap);
            ctx.lineTo(x + ArrowSize.Begin, y + ArrowSize.End);
            ctx.lineTo(x - ArrowSize.Begin, y + ArrowSize.End);
            break;
          case ArrowDirection.Left:
            ctx.moveTo(x - ArrowSize.Gap, y);
            ctx.lineTo(x - ArrowSize.End, y + ArrowSize.Begin);
            ctx.lineTo(x - ArrowSize.End, y - ArrowSize.Begin);
            break;
          case ArrowDirection.Right:
            ctx.moveTo(x + ArrowSize.Gap, y);
            ctx.lineTo(x + ArrowSize.End, y + ArrowSize.Begin);
            ctx.lineTo(x + ArrowSize.End, y - ArrowSize.Begin);
            break;
        }
        ctx.closePath();
        ctx.fill();
      }

      /**
       * Draw a Tetris Block
       * @param {ctx} canvas context
       * @param {x} Board location
       * @param {y} Board location
       * @param {pieceItem} Testis piece items
       */
      function drawPiece(ctx, x, y, pieceItem) {
        // Convert to coordinates to draw on the canvas.
        x *= TetrisDefine.PIECE_IMG_SIZE;
        y *= TetrisDefine.PIECE_IMG_SIZE;

        const cr = pieceItem.Piece;

        for (let i = 0; i < TetrisDefine.PIECE_SIZE; i++) {
          for (let j = 0; j < TetrisDefine.PIECE_SIZE; j++) {
            drawBlock(ctx, x + TetrisDefine.PIECE_IMG_SIZE * j, y + TetrisDefine.PIECE_IMG_SIZE * i, cr[i][j]);
          }
        }
      }

      /**
       * Draw a block.
       * @param {ctx} canvas context
       * @param {x} Pixel position
       * @param {y} Pixel position
       * @param {color} Piece color
       */
      function drawBlock(ctx, x, y, color) {
        let rgba;
        switch (color) {
          case PieceColor.PIECE_NO:
            rgba = "rgba(0, 0, 0, 0.0)";
            break;
          case PieceColor.PIECE_BL:
            rgba = "rgba(0, 0, 0, 1.0)";
            break;
          case PieceColor.PIECE_RD:
            rgba = "rgba(255, 0, 0, 1.0)";
            break;
          case PieceColor.PIECE_YW:
            rgba = "rgba(255, 255, 0, 1.0)";
            break;
          case PieceColor.PIECE_LG:
            rgba = "rgba(0, 255, 0, 1.0)";
            break;
          case PieceColor.PIECE_GR:
            rgba = "rgba(0, 128, 0, 1.0)";
            break;
          case PieceColor.PIECE_BU:
            rgba = "rgba(0, 0, 255, 1.0)";
            break;
          case PieceColor.PIECE_OR:
            rgba = "rgba(255, 165, 0, 1.0)";
            break;
          case PieceColor.PIECE_PP:
            rgba = "rgba(128, 0, 128, 1.0)";
            break;
          case PieceColor.PIECE_NV:
            rgba = "rgba(0, 128, 128, 1.0)";
            break;
          default:
            return;
        }

        // Paint the basic black or nothing, and draw the colored ones in the form of a SquarePyramid.
        if (color == PieceColor.PIECE_BL || color == PieceColor.PIECE_NO) {
          ctx.beginPath();
          ctx.fillStyle = rgba;
          ctx.fillRect(x, y, TetrisDefine.PIECE_IMG_SIZE, TetrisDefine.PIECE_IMG_SIZE);
          ctx.closePath();
        } else {
          drawSquarePyramid(ctx, TetrisDefine.PIECE_IMG_SIZE, x, y, rgba);
        }
      }

      /**
       * Create a square pyramid shape
       * @param {ctx} canvas context
       * @param {size} Shape size
       * @param {x} x
       * @param {y} y
       * @param {rgba} color
       */
      function drawSquarePyramid(ctx, size, x, y, rgba) {
        const half = size / 2;
        const topx = x,
          topy = y;
        const centerx = topx + half,
          centery = topy + half;
        const bottomx = topx + size,
          bottomy = topy + size;

        // Use color groups to create a sense of dimension.
        const colorGroup = getColorLevelGroup(rgba);

        // left
        ctx.fillStyle = colorGroup.left;
        ctx.beginPath();
        ctx.moveTo(topx, topy);
        ctx.lineTo(centerx, centery);
        ctx.lineTo(topx, bottomy);
        ctx.closePath();
        ctx.fill();

        // right
        ctx.fillStyle = colorGroup.right;
        ctx.beginPath();
        ctx.moveTo(bottomx, topy);
        ctx.lineTo(centerx, centery);
        ctx.lineTo(bottomx, bottomy);
        ctx.closePath();
        ctx.fill();

        // up
        ctx.fillStyle = colorGroup.top;
        ctx.beginPath();
        ctx.moveTo(topx, topy);
        ctx.lineTo(centerx, centery);
        ctx.lineTo(bottomx, topy);
        ctx.closePath();
        ctx.fill();

        // down
        ctx.fillStyle = colorGroup.bottom;
        ctx.beginPath();
        ctx.moveTo(topx, bottomy);
        ctx.lineTo(centerx, centery);
        ctx.lineTo(bottomx, bottomy);
        ctx.closePath();
        ctx.fill();
      }

      /**
       * Adjust the brightness of each color channel.
       * @param {r} red
       * @param {g} green
       * @param {b} blue
       * @param {a} alpha
       * @param {amount}
       */
      function makeColorLevel(r, g, b, a, amount) {
        const newR = Math.min(255, Math.max(0, r + amount));
        const newG = Math.min(255, Math.max(0, g + amount));
        const newB = Math.min(255, Math.max(0, b + amount));
        const newA = Number.isNaN(a) ? 1.0 : a;

        // Return a new RGBA value
        return `rgba(${newR}, ${newG}, ${newB}, ${newA})`;
      }

      /**
       * Creating three-dimensional colors.
       * @param {rgb} rgb color value.
       */
      function getColorLevelGroup(rgb) {
        const result = new Object();

        // Extract RGB values
        let rgbSlice = rgb.slice(rgb.indexOf("(") + 1, rgb.indexOf(")")).split(",");
        if (!rgbSlice) {
          // If the RGB value is in an incorrect format, return it as is.
          result.left = rgb;
          result.top = rgb;
          result.bottom = rgb;
          result.right = rgb;

          return result;
        }

        const r = parseInt(rgbSlice[0]);
        const g = parseInt(rgbSlice[1]);
        const b = parseInt(rgbSlice[2]);
        const a = parseInt(rgbSlice[3]);

        // The left side is the lightest, followed by the top and bottom, and the right side is the darkest.
        result.left = makeColorLevel(r, g, b, a, 20);
        result.top = makeColorLevel(r, g, b, a, 0);
        result.bottom = makeColorLevel(r, g, b, a, -20);
        result.right = makeColorLevel(r, g, b, a, -40);

        return result;
      }

      /**
       * Show shadowed text
       * @param {ctx} canvas context
       * @param {font} Font size and shape
       * @param {shadowColor} Background color.
       * @param {txtColor} font color
       * @param {msg} message
       * @param {align} align
       * @param {x} x
       * @param {y} y
       */
      function drawShedowText(ctx, font, shadowColor, txtColor, msg, align, x, y) {
        ctx.font = font;
        ctx.shadowColor = shadowColor;
        ctx.shadowBlur = 6;
        ctx.lineWidth = 2;
        ctx.textAlign = align;
        ctx.strokeText(msg, x, y);
        ctx.shadowBlur = 0;
        ctx.fillStyle = txtColor;
        ctx.textAlign = align;
        ctx.fillText(msg, x, y);
      }

      /**
       * Clear canvas
       * @param {ctx} canvas context
       */
      function clearCanvas(ctx) {
        const canvas = ctx.canvas;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      /**
       * Draw a test board
       * @param {tetris} tetris instance
       */
      function draw(tetris) {
        const ctx = tetris.ctx;
        clearCanvas(ctx);
        clearCanvas(tetris.waitCtx);

        if (tetris.status == TetrisStatus.Begin) {
          drawShedowText(ctx, "15px Arial", "black", "yellow", "Start", "center", tetris.canvas.width / 2, tetris.canvas.height / 2);
          drawShedowText(ctx, "20px Arial", "blue", "white", "Touch", "center", tetris.canvas.width / 2, tetris.canvas.height / 2 + 30);

          requestAnimationFrame(function (timestamp) {
            draw(tetris);
          });
          return;
        }

        // Show the Tetris board
        for (let y = TetrisDefine.MATRIX_BETWEEN, j = 0; y < TetrisDefine.MATRIX_WORK_Y; y++, j++) {
          for (let x = TetrisDefine.MATRIX_BETWEEN, i = 0; x < TetrisDefine.MATRIX_WORK_X; x++, i++) {
            drawBlock(ctx, i * TetrisDefine.PIECE_IMG_SIZE, j * TetrisDefine.PIECE_IMG_SIZE, tetris.board.Board[y][x]);
          }
        }

        // drawing pieces
        if (tetris.status == TetrisStatus.Play) {
          drawPiece(ctx, tetris.play.x - TetrisDefine.MATRIX_BETWEEN, tetris.play.y - TetrisDefine.MATRIX_BETWEEN, tetris.playPiece);
          // Draw the next waiting item.
          drawPiece(tetris.waitCtx, 0, 0, tetris.waitPiece);
          // Drawing touch events
          tetris.arrows.list.forEach((arrow) => drawArrow(ctx, arrow));
        }

        // drawing point
        drawShedowText(ctx, "14px Arial", "cyan", "cyan", tetris.gamePoint, "right", tetris.canvas.width - 10, 20);

        // drawing game over.
        if (tetris.status == TetrisStatus.Finish) {
          drawShedowText(ctx, "20px Arial", "white", "white", "The end.", "center", tetris.canvas.width / 2, tetris.canvas.height / 2);
        }

        requestAnimationFrame(function (timestamp) {
          draw(tetris);
        });
      }
    </script>
  </head>
  <body onload="loadBody();">
    <canvas id="canvasBoard"></canvas>
    <div>
      <table>
        <tr>
          <td><canvas id="canvasNext"></canvas></td>
          <td>
            <table>
              <tr>
                <td id="btnInit" style="background-color: antiquewhite; text-align: left; cursor: pointer">Init</td>
                <td id="btnRotate" style="background-color: coral; text-align: center; cursor: pointer">Rotate</td>
                <td></td>
              </tr>
              <tr>
                <td id="btnLeft" style="background-color: coral; text-align: left; cursor: pointer">Left</td>
                <td id="btnDown" style="background-color: violet; text-align: center; cursor: pointer">Down</td>
                <td id="btnRight" style="background-color: coral; text-align: right; cursor: pointer">Right</td>
              </tr>
              <tr>
                <td></td>
                <td id="btnBottom" style="background-color: coral; text-align: center; cursor: pointer">Bottom</td>
                <td></td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
    </div>
  </body>
</html>
